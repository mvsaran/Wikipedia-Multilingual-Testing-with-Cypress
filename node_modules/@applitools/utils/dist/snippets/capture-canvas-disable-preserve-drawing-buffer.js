"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.disableCanvasPreserveDrawingBuffer = void 0;
function disableCanvasPreserveDrawingBuffer() {
    function disablePreserveDrawingBuffer() {
        if (HTMLCanvasElement.prototype.__isPatchedForDisablePreserveDrawingBuffer) {
            // eslint-disable-next-line no-console
            console.log('Canvas preserveDrawingBuffer patch has already been applied.');
            return;
        }
        // eslint-disable-next-line no-console
        console.log('Applying canvas preserveDrawingBuffer patch...');
        const originalGetContext = HTMLCanvasElement.prototype.getContext;
        function getContextPatched(contextId, contextAttributes) {
            if (contextId === 'webgl' || contextId === 'webgl2') {
                if (typeof contextAttributes !== 'object' || contextAttributes === null) {
                    contextAttributes = {};
                }
                contextAttributes.preserveDrawingBuffer = false;
            }
            return originalGetContext.apply(this, [contextId, contextAttributes]);
        }
        HTMLCanvasElement.prototype.getContext = getContextPatched;
        Object.defineProperty(HTMLCanvasElement.prototype, '__isPatchedForDisablePreserveDrawingBuffer', {
            value: true,
            writable: false,
            configurable: true,
        });
    }
    // eslint-disable-next-line no-console
    console.log('âœ… Patch applied. New WebGL contexts will now not preserve their drawing buffer.');
    if (typeof window !== 'undefined') {
        Object.assign(window, { disablePreserveDrawingBuffer });
    }
    disablePreserveDrawingBuffer();
}
exports.disableCanvasPreserveDrawingBuffer = disableCanvasPreserveDrawingBuffer;
